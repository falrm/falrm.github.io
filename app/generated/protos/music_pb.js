// source: protos/music.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

goog.exportSymbol('proto.Chord', null, global);
goog.exportSymbol('proto.Harmony', null, global);
goog.exportSymbol('proto.Instrument', null, global);
goog.exportSymbol('proto.InstrumentType', null, global);
goog.exportSymbol('proto.MelodicAttack', null, global);
goog.exportSymbol('proto.Melody', null, global);
goog.exportSymbol('proto.Melody.DataCase', null, global);
goog.exportSymbol('proto.MelodyInterpretationType', null, global);
goog.exportSymbol('proto.MelodyReference', null, global);
goog.exportSymbol('proto.MelodyReference.PlaybackType', null, global);
goog.exportSymbol('proto.MelodyType', null, global);
goog.exportSymbol('proto.Meter', null, global);
goog.exportSymbol('proto.MidiChange', null, global);
goog.exportSymbol('proto.MidiData', null, global);
goog.exportSymbol('proto.NoteLetter', null, global);
goog.exportSymbol('proto.NoteName', null, global);
goog.exportSymbol('proto.NoteSign', null, global);
goog.exportSymbol('proto.Part', null, global);
goog.exportSymbol('proto.Score', null, global);
goog.exportSymbol('proto.Section', null, global);
goog.exportSymbol('proto.Section.Color', null, global);
goog.exportSymbol('proto.Tempo', null, global);
goog.exportSymbol('proto.Tempo.Transition', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.NoteName = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.NoteName, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.NoteName.displayName = 'proto.NoteName';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Chord = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.Chord, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.Chord.displayName = 'proto.Chord';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Tempo = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.Tempo, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.Tempo.displayName = 'proto.Tempo';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Meter = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.Meter, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.Meter.displayName = 'proto.Meter';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Harmony = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.Harmony, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.Harmony.displayName = 'proto.Harmony';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Melody = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.Melody.oneofGroups_);
};
goog.inherits(proto.Melody, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.Melody.displayName = 'proto.Melody';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.MidiData = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.MidiData, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.MidiData.displayName = 'proto.MidiData';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.MelodicAttack = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.MelodicAttack.repeatedFields_, null);
};
goog.inherits(proto.MelodicAttack, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.MelodicAttack.displayName = 'proto.MelodicAttack';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.MidiChange = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.MidiChange, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.MidiChange.displayName = 'proto.MidiChange';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Instrument = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.Instrument, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.Instrument.displayName = 'proto.Instrument';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Part = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.Part.repeatedFields_, null);
};
goog.inherits(proto.Part, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.Part.displayName = 'proto.Part';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.MelodyReference = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.MelodyReference, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.MelodyReference.displayName = 'proto.MelodyReference';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Section = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.Section.repeatedFields_, null);
};
goog.inherits(proto.Section, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.Section.displayName = 'proto.Section';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Score = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.Score.repeatedFields_, null);
};
goog.inherits(proto.Score, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.Score.displayName = 'proto.Score';
}



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.NoteName.prototype.toObject = function(opt_includeInstance) {
  return proto.NoteName.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.NoteName} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.NoteName.toObject = function(includeInstance, msg) {
  var f, obj = {
    noteLetter: jspb.Message.getFieldWithDefault(msg, 1, 0),
    noteSign: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.NoteName}
 */
proto.NoteName.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.NoteName;
  return proto.NoteName.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.NoteName} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.NoteName}
 */
proto.NoteName.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.NoteLetter} */ (reader.readEnum());
      msg.setNoteLetter(value);
      break;
    case 2:
      var value = /** @type {!proto.NoteSign} */ (reader.readEnum());
      msg.setNoteSign(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.NoteName.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.NoteName.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.NoteName} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.NoteName.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNoteLetter();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getNoteSign();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
};


/**
 * optional NoteLetter note_letter = 1;
 * @return {!proto.NoteLetter}
 */
proto.NoteName.prototype.getNoteLetter = function() {
  return /** @type {!proto.NoteLetter} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.NoteLetter} value
 * @return {!proto.NoteName} returns this
 */
proto.NoteName.prototype.setNoteLetter = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional NoteSign note_sign = 2;
 * @return {!proto.NoteSign}
 */
proto.NoteName.prototype.getNoteSign = function() {
  return /** @type {!proto.NoteSign} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {!proto.NoteSign} value
 * @return {!proto.NoteName} returns this
 */
proto.NoteName.prototype.setNoteSign = function(value) {
  return jspb.Message.setProto3EnumField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.Chord.prototype.toObject = function(opt_includeInstance) {
  return proto.Chord.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.Chord} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Chord.toObject = function(includeInstance, msg) {
  var f, obj = {
    rootNote: (f = msg.getRootNote()) && proto.NoteName.toObject(includeInstance, f),
    bassNote: (f = msg.getBassNote()) && proto.NoteName.toObject(includeInstance, f),
    chroma: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Chord}
 */
proto.Chord.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Chord;
  return proto.Chord.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Chord} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Chord}
 */
proto.Chord.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.NoteName;
      reader.readMessage(value,proto.NoteName.deserializeBinaryFromReader);
      msg.setRootNote(value);
      break;
    case 2:
      var value = new proto.NoteName;
      reader.readMessage(value,proto.NoteName.deserializeBinaryFromReader);
      msg.setBassNote(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setChroma(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Chord.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.Chord.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.Chord} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Chord.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRootNote();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.NoteName.serializeBinaryToWriter
    );
  }
  f = message.getBassNote();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.NoteName.serializeBinaryToWriter
    );
  }
  f = message.getChroma();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
};


/**
 * optional NoteName root_note = 1;
 * @return {?proto.NoteName}
 */
proto.Chord.prototype.getRootNote = function() {
  return /** @type{?proto.NoteName} */ (
    jspb.Message.getWrapperField(this, proto.NoteName, 1));
};


/**
 * @param {?proto.NoteName|undefined} value
 * @return {!proto.Chord} returns this
*/
proto.Chord.prototype.setRootNote = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.Chord} returns this
 */
proto.Chord.prototype.clearRootNote = function() {
  return this.setRootNote(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.Chord.prototype.hasRootNote = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional NoteName bass_note = 2;
 * @return {?proto.NoteName}
 */
proto.Chord.prototype.getBassNote = function() {
  return /** @type{?proto.NoteName} */ (
    jspb.Message.getWrapperField(this, proto.NoteName, 2));
};


/**
 * @param {?proto.NoteName|undefined} value
 * @return {!proto.Chord} returns this
*/
proto.Chord.prototype.setBassNote = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.Chord} returns this
 */
proto.Chord.prototype.clearBassNote = function() {
  return this.setBassNote(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.Chord.prototype.hasBassNote = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint32 chroma = 3;
 * @return {number}
 */
proto.Chord.prototype.getChroma = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.Chord} returns this
 */
proto.Chord.prototype.setChroma = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.Tempo.prototype.toObject = function(opt_includeInstance) {
  return proto.Tempo.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.Tempo} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Tempo.toObject = function(includeInstance, msg) {
  var f, obj = {
    bpm: jspb.Message.getFloatingPointFieldWithDefault(msg, 1, 0.0),
    transition: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Tempo}
 */
proto.Tempo.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Tempo;
  return proto.Tempo.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Tempo} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Tempo}
 */
proto.Tempo.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setBpm(value);
      break;
    case 2:
      var value = /** @type {!proto.Tempo.Transition} */ (reader.readEnum());
      msg.setTransition(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Tempo.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.Tempo.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.Tempo} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Tempo.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBpm();
  if (f !== 0.0) {
    writer.writeFloat(
      1,
      f
    );
  }
  f = message.getTransition();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.Tempo.Transition = {
  A_TEMPO: 0,
  LINEAR: 1
};

/**
 * optional float bpm = 1;
 * @return {number}
 */
proto.Tempo.prototype.getBpm = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 1, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.Tempo} returns this
 */
proto.Tempo.prototype.setBpm = function(value) {
  return jspb.Message.setProto3FloatField(this, 1, value);
};


/**
 * optional Transition transition = 2;
 * @return {!proto.Tempo.Transition}
 */
proto.Tempo.prototype.getTransition = function() {
  return /** @type {!proto.Tempo.Transition} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {!proto.Tempo.Transition} value
 * @return {!proto.Tempo} returns this
 */
proto.Tempo.prototype.setTransition = function(value) {
  return jspb.Message.setProto3EnumField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.Meter.prototype.toObject = function(opt_includeInstance) {
  return proto.Meter.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.Meter} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Meter.toObject = function(includeInstance, msg) {
  var f, obj = {
    defaultBeatsPerMeasure: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Meter}
 */
proto.Meter.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Meter;
  return proto.Meter.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Meter} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Meter}
 */
proto.Meter.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setDefaultBeatsPerMeasure(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Meter.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.Meter.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.Meter} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Meter.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDefaultBeatsPerMeasure();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 default_beats_per_measure = 1;
 * @return {number}
 */
proto.Meter.prototype.getDefaultBeatsPerMeasure = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.Meter} returns this
 */
proto.Meter.prototype.setDefaultBeatsPerMeasure = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.Harmony.prototype.toObject = function(opt_includeInstance) {
  return proto.Harmony.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.Harmony} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Harmony.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: jspb.Message.getFieldWithDefault(msg, 1, ""),
    subdivisionsPerBeat: jspb.Message.getFieldWithDefault(msg, 2, 0),
    length: jspb.Message.getFieldWithDefault(msg, 3, 0),
    dataMap: (f = msg.getDataMap()) ? f.toObject(includeInstance, proto.Chord.toObject) : []
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Harmony}
 */
proto.Harmony.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Harmony;
  return proto.Harmony.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Harmony} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Harmony}
 */
proto.Harmony.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSubdivisionsPerBeat(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLength(value);
      break;
    case 100:
      var value = msg.getDataMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readSint32, jspb.BinaryReader.prototype.readMessage, proto.Chord.deserializeBinaryFromReader, 0, new proto.Chord());
         });
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Harmony.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.Harmony.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.Harmony} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Harmony.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getSubdivisionsPerBeat();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getLength();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = message.getDataMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(100, writer, jspb.BinaryWriter.prototype.writeSint32, jspb.BinaryWriter.prototype.writeMessage, proto.Chord.serializeBinaryToWriter);
  }
};


/**
 * optional string id = 1;
 * @return {string}
 */
proto.Harmony.prototype.getId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.Harmony} returns this
 */
proto.Harmony.prototype.setId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional uint32 subdivisions_per_beat = 2;
 * @return {number}
 */
proto.Harmony.prototype.getSubdivisionsPerBeat = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.Harmony} returns this
 */
proto.Harmony.prototype.setSubdivisionsPerBeat = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional uint32 length = 3;
 * @return {number}
 */
proto.Harmony.prototype.getLength = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.Harmony} returns this
 */
proto.Harmony.prototype.setLength = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * map<sint32, Chord> data = 100;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<number,!proto.Chord>}
 */
proto.Harmony.prototype.getDataMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<number,!proto.Chord>} */ (
      jspb.Message.getMapField(this, 100, opt_noLazyCreate,
      proto.Chord));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.Harmony} returns this
 */
proto.Harmony.prototype.clearDataMap = function() {
  this.getDataMap().clear();
  return this;};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.Melody.oneofGroups_ = [[101]];

/**
 * @enum {number}
 */
proto.Melody.DataCase = {
  DATA_NOT_SET: 0,
  MIDI_DATA: 101
};

/**
 * @return {proto.Melody.DataCase}
 */
proto.Melody.prototype.getDataCase = function() {
  return /** @type {proto.Melody.DataCase} */(jspb.Message.computeOneofCase(this, proto.Melody.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.Melody.prototype.toObject = function(opt_includeInstance) {
  return proto.Melody.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.Melody} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Melody.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: jspb.Message.getFieldWithDefault(msg, 1, ""),
    name: jspb.Message.getFieldWithDefault(msg, 2, ""),
    subdivisionsPerBeat: jspb.Message.getFieldWithDefault(msg, 3, 0),
    length: jspb.Message.getFieldWithDefault(msg, 4, 0),
    type: jspb.Message.getFieldWithDefault(msg, 5, 0),
    instrumentType: jspb.Message.getFieldWithDefault(msg, 6, 0),
    interpretationType: jspb.Message.getFieldWithDefault(msg, 7, 0),
    midiData: (f = msg.getMidiData()) && proto.MidiData.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Melody}
 */
proto.Melody.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Melody;
  return proto.Melody.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Melody} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Melody}
 */
proto.Melody.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSubdivisionsPerBeat(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLength(value);
      break;
    case 5:
      var value = /** @type {!proto.MelodyType} */ (reader.readEnum());
      msg.setType(value);
      break;
    case 6:
      var value = /** @type {!proto.InstrumentType} */ (reader.readEnum());
      msg.setInstrumentType(value);
      break;
    case 7:
      var value = /** @type {!proto.MelodyInterpretationType} */ (reader.readEnum());
      msg.setInterpretationType(value);
      break;
    case 101:
      var value = new proto.MidiData;
      reader.readMessage(value,proto.MidiData.deserializeBinaryFromReader);
      msg.setMidiData(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Melody.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.Melody.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.Melody} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Melody.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getSubdivisionsPerBeat();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = message.getLength();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getType();
  if (f !== 0.0) {
    writer.writeEnum(
      5,
      f
    );
  }
  f = message.getInstrumentType();
  if (f !== 0.0) {
    writer.writeEnum(
      6,
      f
    );
  }
  f = message.getInterpretationType();
  if (f !== 0.0) {
    writer.writeEnum(
      7,
      f
    );
  }
  f = message.getMidiData();
  if (f != null) {
    writer.writeMessage(
      101,
      f,
      proto.MidiData.serializeBinaryToWriter
    );
  }
};


/**
 * optional string id = 1;
 * @return {string}
 */
proto.Melody.prototype.getId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.Melody} returns this
 */
proto.Melody.prototype.setId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string name = 2;
 * @return {string}
 */
proto.Melody.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.Melody} returns this
 */
proto.Melody.prototype.setName = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional uint32 subdivisions_per_beat = 3;
 * @return {number}
 */
proto.Melody.prototype.getSubdivisionsPerBeat = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.Melody} returns this
 */
proto.Melody.prototype.setSubdivisionsPerBeat = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional uint32 length = 4;
 * @return {number}
 */
proto.Melody.prototype.getLength = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.Melody} returns this
 */
proto.Melody.prototype.setLength = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional MelodyType type = 5;
 * @return {!proto.MelodyType}
 */
proto.Melody.prototype.getType = function() {
  return /** @type {!proto.MelodyType} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/**
 * @param {!proto.MelodyType} value
 * @return {!proto.Melody} returns this
 */
proto.Melody.prototype.setType = function(value) {
  return jspb.Message.setProto3EnumField(this, 5, value);
};


/**
 * optional InstrumentType instrument_type = 6;
 * @return {!proto.InstrumentType}
 */
proto.Melody.prototype.getInstrumentType = function() {
  return /** @type {!proto.InstrumentType} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/**
 * @param {!proto.InstrumentType} value
 * @return {!proto.Melody} returns this
 */
proto.Melody.prototype.setInstrumentType = function(value) {
  return jspb.Message.setProto3EnumField(this, 6, value);
};


/**
 * optional MelodyInterpretationType interpretation_type = 7;
 * @return {!proto.MelodyInterpretationType}
 */
proto.Melody.prototype.getInterpretationType = function() {
  return /** @type {!proto.MelodyInterpretationType} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/**
 * @param {!proto.MelodyInterpretationType} value
 * @return {!proto.Melody} returns this
 */
proto.Melody.prototype.setInterpretationType = function(value) {
  return jspb.Message.setProto3EnumField(this, 7, value);
};


/**
 * optional MidiData midi_data = 101;
 * @return {?proto.MidiData}
 */
proto.Melody.prototype.getMidiData = function() {
  return /** @type{?proto.MidiData} */ (
    jspb.Message.getWrapperField(this, proto.MidiData, 101));
};


/**
 * @param {?proto.MidiData|undefined} value
 * @return {!proto.Melody} returns this
*/
proto.Melody.prototype.setMidiData = function(value) {
  return jspb.Message.setOneofWrapperField(this, 101, proto.Melody.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.Melody} returns this
 */
proto.Melody.prototype.clearMidiData = function() {
  return this.setMidiData(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.Melody.prototype.hasMidiData = function() {
  return jspb.Message.getField(this, 101) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.MidiData.prototype.toObject = function(opt_includeInstance) {
  return proto.MidiData.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.MidiData} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.MidiData.toObject = function(includeInstance, msg) {
  var f, obj = {
    dataMap: (f = msg.getDataMap()) ? f.toObject(includeInstance, proto.MidiChange.toObject) : []
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.MidiData}
 */
proto.MidiData.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.MidiData;
  return proto.MidiData.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.MidiData} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.MidiData}
 */
proto.MidiData.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = msg.getDataMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readSint32, jspb.BinaryReader.prototype.readMessage, proto.MidiChange.deserializeBinaryFromReader, 0, new proto.MidiChange());
         });
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.MidiData.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.MidiData.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.MidiData} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.MidiData.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDataMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(1, writer, jspb.BinaryWriter.prototype.writeSint32, jspb.BinaryWriter.prototype.writeMessage, proto.MidiChange.serializeBinaryToWriter);
  }
};


/**
 * map<sint32, MidiChange> data = 1;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<number,!proto.MidiChange>}
 */
proto.MidiData.prototype.getDataMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<number,!proto.MidiChange>} */ (
      jspb.Message.getMapField(this, 1, opt_noLazyCreate,
      proto.MidiChange));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.MidiData} returns this
 */
proto.MidiData.prototype.clearDataMap = function() {
  this.getDataMap().clear();
  return this;};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.MelodicAttack.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.MelodicAttack.prototype.toObject = function(opt_includeInstance) {
  return proto.MelodicAttack.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.MelodicAttack} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.MelodicAttack.toObject = function(includeInstance, msg) {
  var f, obj = {
    tonesList: (f = jspb.Message.getRepeatedField(msg, 1)) == null ? undefined : f,
    velocity: jspb.Message.getFloatingPointFieldWithDefault(msg, 2, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.MelodicAttack}
 */
proto.MelodicAttack.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.MelodicAttack;
  return proto.MelodicAttack.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.MelodicAttack} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.MelodicAttack}
 */
proto.MelodicAttack.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Array<number>} */ (reader.readPackedSint32());
      msg.setTonesList(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setVelocity(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.MelodicAttack.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.MelodicAttack.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.MelodicAttack} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.MelodicAttack.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTonesList();
  if (f.length > 0) {
    writer.writePackedSint32(
      1,
      f
    );
  }
  f = message.getVelocity();
  if (f !== 0.0) {
    writer.writeFloat(
      2,
      f
    );
  }
};


/**
 * repeated sint32 tones = 1;
 * @return {!Array<number>}
 */
proto.MelodicAttack.prototype.getTonesList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 1));
};


/**
 * @param {!Array<number>} value
 * @return {!proto.MelodicAttack} returns this
 */
proto.MelodicAttack.prototype.setTonesList = function(value) {
  return jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {number} value
 * @param {number=} opt_index
 * @return {!proto.MelodicAttack} returns this
 */
proto.MelodicAttack.prototype.addTones = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.MelodicAttack} returns this
 */
proto.MelodicAttack.prototype.clearTonesList = function() {
  return this.setTonesList([]);
};


/**
 * optional float velocity = 2;
 * @return {number}
 */
proto.MelodicAttack.prototype.getVelocity = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 2, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.MelodicAttack} returns this
 */
proto.MelodicAttack.prototype.setVelocity = function(value) {
  return jspb.Message.setProto3FloatField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.MidiChange.prototype.toObject = function(opt_includeInstance) {
  return proto.MidiChange.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.MidiChange} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.MidiChange.toObject = function(includeInstance, msg) {
  var f, obj = {
    data: msg.getData_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.MidiChange}
 */
proto.MidiChange.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.MidiChange;
  return proto.MidiChange.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.MidiChange} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.MidiChange}
 */
proto.MidiChange.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setData(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.MidiChange.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.MidiChange.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.MidiChange} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.MidiChange.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getData_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes data = 1;
 * @return {string}
 */
proto.MidiChange.prototype.getData = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes data = 1;
 * This is a type-conversion wrapper around `getData()`
 * @return {string}
 */
proto.MidiChange.prototype.getData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getData()));
};


/**
 * optional bytes data = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getData()`
 * @return {!Uint8Array}
 */
proto.MidiChange.prototype.getData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getData()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.MidiChange} returns this
 */
proto.MidiChange.prototype.setData = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.Instrument.prototype.toObject = function(opt_includeInstance) {
  return proto.Instrument.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.Instrument} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Instrument.toObject = function(includeInstance, msg) {
  var f, obj = {
    name: jspb.Message.getFieldWithDefault(msg, 1, ""),
    type: jspb.Message.getFieldWithDefault(msg, 2, 0),
    volume: jspb.Message.getFloatingPointFieldWithDefault(msg, 3, 0.0),
    midiChannel: jspb.Message.getFieldWithDefault(msg, 4, 0),
    midiInstrument: jspb.Message.getFieldWithDefault(msg, 5, 0),
    midiGm2Msb: jspb.Message.getFieldWithDefault(msg, 6, 0),
    midiGm2Lsb: jspb.Message.getFieldWithDefault(msg, 7, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Instrument}
 */
proto.Instrument.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Instrument;
  return proto.Instrument.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Instrument} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Instrument}
 */
proto.Instrument.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 2:
      var value = /** @type {!proto.InstrumentType} */ (reader.readEnum());
      msg.setType(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setVolume(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMidiChannel(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMidiInstrument(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMidiGm2Msb(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMidiGm2Lsb(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Instrument.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.Instrument.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.Instrument} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Instrument.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getName();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getType();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = message.getVolume();
  if (f !== 0.0) {
    writer.writeFloat(
      3,
      f
    );
  }
  f = message.getMidiChannel();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getMidiInstrument();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = message.getMidiGm2Msb();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
  f = message.getMidiGm2Lsb();
  if (f !== 0) {
    writer.writeUint32(
      7,
      f
    );
  }
};


/**
 * optional string name = 1;
 * @return {string}
 */
proto.Instrument.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.Instrument} returns this
 */
proto.Instrument.prototype.setName = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional InstrumentType type = 2;
 * @return {!proto.InstrumentType}
 */
proto.Instrument.prototype.getType = function() {
  return /** @type {!proto.InstrumentType} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {!proto.InstrumentType} value
 * @return {!proto.Instrument} returns this
 */
proto.Instrument.prototype.setType = function(value) {
  return jspb.Message.setProto3EnumField(this, 2, value);
};


/**
 * optional float volume = 3;
 * @return {number}
 */
proto.Instrument.prototype.getVolume = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 3, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.Instrument} returns this
 */
proto.Instrument.prototype.setVolume = function(value) {
  return jspb.Message.setProto3FloatField(this, 3, value);
};


/**
 * optional uint32 midi_channel = 4;
 * @return {number}
 */
proto.Instrument.prototype.getMidiChannel = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.Instrument} returns this
 */
proto.Instrument.prototype.setMidiChannel = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional uint32 midi_instrument = 5;
 * @return {number}
 */
proto.Instrument.prototype.getMidiInstrument = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/**
 * @param {number} value
 * @return {!proto.Instrument} returns this
 */
proto.Instrument.prototype.setMidiInstrument = function(value) {
  return jspb.Message.setProto3IntField(this, 5, value);
};


/**
 * optional uint32 midi_gm2_msb = 6;
 * @return {number}
 */
proto.Instrument.prototype.getMidiGm2Msb = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/**
 * @param {number} value
 * @return {!proto.Instrument} returns this
 */
proto.Instrument.prototype.setMidiGm2Msb = function(value) {
  return jspb.Message.setProto3IntField(this, 6, value);
};


/**
 * optional uint32 midi_gm2_lsb = 7;
 * @return {number}
 */
proto.Instrument.prototype.getMidiGm2Lsb = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/**
 * @param {number} value
 * @return {!proto.Instrument} returns this
 */
proto.Instrument.prototype.setMidiGm2Lsb = function(value) {
  return jspb.Message.setProto3IntField(this, 7, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.Part.repeatedFields_ = [4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.Part.prototype.toObject = function(opt_includeInstance) {
  return proto.Part.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.Part} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Part.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: jspb.Message.getFieldWithDefault(msg, 1, ""),
    instrument: (f = msg.getInstrument()) && proto.Instrument.toObject(includeInstance, f),
    melodiesList: jspb.Message.toObjectList(msg.getMelodiesList(),
    proto.Melody.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Part}
 */
proto.Part.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Part;
  return proto.Part.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Part} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Part}
 */
proto.Part.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setId(value);
      break;
    case 3:
      var value = new proto.Instrument;
      reader.readMessage(value,proto.Instrument.deserializeBinaryFromReader);
      msg.setInstrument(value);
      break;
    case 4:
      var value = new proto.Melody;
      reader.readMessage(value,proto.Melody.deserializeBinaryFromReader);
      msg.addMelodies(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Part.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.Part.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.Part} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Part.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getInstrument();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.Instrument.serializeBinaryToWriter
    );
  }
  f = message.getMelodiesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.Melody.serializeBinaryToWriter
    );
  }
};


/**
 * optional string id = 1;
 * @return {string}
 */
proto.Part.prototype.getId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.Part} returns this
 */
proto.Part.prototype.setId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional Instrument instrument = 3;
 * @return {?proto.Instrument}
 */
proto.Part.prototype.getInstrument = function() {
  return /** @type{?proto.Instrument} */ (
    jspb.Message.getWrapperField(this, proto.Instrument, 3));
};


/**
 * @param {?proto.Instrument|undefined} value
 * @return {!proto.Part} returns this
*/
proto.Part.prototype.setInstrument = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.Part} returns this
 */
proto.Part.prototype.clearInstrument = function() {
  return this.setInstrument(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.Part.prototype.hasInstrument = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * repeated Melody melodies = 4;
 * @return {!Array<!proto.Melody>}
 */
proto.Part.prototype.getMelodiesList = function() {
  return /** @type{!Array<!proto.Melody>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.Melody, 4));
};


/**
 * @param {!Array<!proto.Melody>} value
 * @return {!proto.Part} returns this
*/
proto.Part.prototype.setMelodiesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.Melody=} opt_value
 * @param {number=} opt_index
 * @return {!proto.Melody}
 */
proto.Part.prototype.addMelodies = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.Melody, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.Part} returns this
 */
proto.Part.prototype.clearMelodiesList = function() {
  return this.setMelodiesList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.MelodyReference.prototype.toObject = function(opt_includeInstance) {
  return proto.MelodyReference.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.MelodyReference} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.MelodyReference.toObject = function(includeInstance, msg) {
  var f, obj = {
    melodyId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    playbackType: jspb.Message.getFieldWithDefault(msg, 2, 0),
    volume: jspb.Message.getFloatingPointFieldWithDefault(msg, 3, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.MelodyReference}
 */
proto.MelodyReference.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.MelodyReference;
  return proto.MelodyReference.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.MelodyReference} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.MelodyReference}
 */
proto.MelodyReference.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMelodyId(value);
      break;
    case 2:
      var value = /** @type {!proto.MelodyReference.PlaybackType} */ (reader.readEnum());
      msg.setPlaybackType(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setVolume(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.MelodyReference.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.MelodyReference.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.MelodyReference} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.MelodyReference.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMelodyId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getPlaybackType();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = message.getVolume();
  if (f !== 0.0) {
    writer.writeFloat(
      3,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.MelodyReference.PlaybackType = {
  DISABLED: 0,
  PLAYBACK_INDEFINITELY: 1
};

/**
 * optional string melody_id = 1;
 * @return {string}
 */
proto.MelodyReference.prototype.getMelodyId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.MelodyReference} returns this
 */
proto.MelodyReference.prototype.setMelodyId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional PlaybackType playback_type = 2;
 * @return {!proto.MelodyReference.PlaybackType}
 */
proto.MelodyReference.prototype.getPlaybackType = function() {
  return /** @type {!proto.MelodyReference.PlaybackType} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {!proto.MelodyReference.PlaybackType} value
 * @return {!proto.MelodyReference} returns this
 */
proto.MelodyReference.prototype.setPlaybackType = function(value) {
  return jspb.Message.setProto3EnumField(this, 2, value);
};


/**
 * optional float volume = 3;
 * @return {number}
 */
proto.MelodyReference.prototype.getVolume = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 3, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.MelodyReference} returns this
 */
proto.MelodyReference.prototype.setVolume = function(value) {
  return jspb.Message.setProto3FloatField(this, 3, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.Section.repeatedFields_ = [100];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.Section.prototype.toObject = function(opt_includeInstance) {
  return proto.Section.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.Section} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Section.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: jspb.Message.getFieldWithDefault(msg, 1, ""),
    name: jspb.Message.getFieldWithDefault(msg, 2, ""),
    harmony: (f = msg.getHarmony()) && proto.Harmony.toObject(includeInstance, f),
    meter: (f = msg.getMeter()) && proto.Meter.toObject(includeInstance, f),
    tempo: (f = msg.getTempo()) && proto.Tempo.toObject(includeInstance, f),
    key: (f = msg.getKey()) && proto.NoteName.toObject(includeInstance, f),
    melodiesList: jspb.Message.toObjectList(msg.getMelodiesList(),
    proto.MelodyReference.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Section}
 */
proto.Section.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Section;
  return proto.Section.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Section} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Section}
 */
proto.Section.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 3:
      var value = new proto.Harmony;
      reader.readMessage(value,proto.Harmony.deserializeBinaryFromReader);
      msg.setHarmony(value);
      break;
    case 4:
      var value = new proto.Meter;
      reader.readMessage(value,proto.Meter.deserializeBinaryFromReader);
      msg.setMeter(value);
      break;
    case 5:
      var value = new proto.Tempo;
      reader.readMessage(value,proto.Tempo.deserializeBinaryFromReader);
      msg.setTempo(value);
      break;
    case 6:
      var value = new proto.NoteName;
      reader.readMessage(value,proto.NoteName.deserializeBinaryFromReader);
      msg.setKey(value);
      break;
    case 100:
      var value = new proto.MelodyReference;
      reader.readMessage(value,proto.MelodyReference.deserializeBinaryFromReader);
      msg.addMelodies(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Section.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.Section.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.Section} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Section.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getHarmony();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.Harmony.serializeBinaryToWriter
    );
  }
  f = message.getMeter();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.Meter.serializeBinaryToWriter
    );
  }
  f = message.getTempo();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.Tempo.serializeBinaryToWriter
    );
  }
  f = message.getKey();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.NoteName.serializeBinaryToWriter
    );
  }
  f = message.getMelodiesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      100,
      f,
      proto.MelodyReference.serializeBinaryToWriter
    );
  }
};


/**
 * @enum {number}
 */
proto.Section.Color = {
  MAJOR: 0,
  MINOR: 1,
  DOMINANT: 2,
  AUGMENTED: 3,
  DIMINISHED: 4
};

/**
 * optional string id = 1;
 * @return {string}
 */
proto.Section.prototype.getId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.Section} returns this
 */
proto.Section.prototype.setId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string name = 2;
 * @return {string}
 */
proto.Section.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.Section} returns this
 */
proto.Section.prototype.setName = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional Harmony harmony = 3;
 * @return {?proto.Harmony}
 */
proto.Section.prototype.getHarmony = function() {
  return /** @type{?proto.Harmony} */ (
    jspb.Message.getWrapperField(this, proto.Harmony, 3));
};


/**
 * @param {?proto.Harmony|undefined} value
 * @return {!proto.Section} returns this
*/
proto.Section.prototype.setHarmony = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.Section} returns this
 */
proto.Section.prototype.clearHarmony = function() {
  return this.setHarmony(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.Section.prototype.hasHarmony = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional Meter meter = 4;
 * @return {?proto.Meter}
 */
proto.Section.prototype.getMeter = function() {
  return /** @type{?proto.Meter} */ (
    jspb.Message.getWrapperField(this, proto.Meter, 4));
};


/**
 * @param {?proto.Meter|undefined} value
 * @return {!proto.Section} returns this
*/
proto.Section.prototype.setMeter = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.Section} returns this
 */
proto.Section.prototype.clearMeter = function() {
  return this.setMeter(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.Section.prototype.hasMeter = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional Tempo tempo = 5;
 * @return {?proto.Tempo}
 */
proto.Section.prototype.getTempo = function() {
  return /** @type{?proto.Tempo} */ (
    jspb.Message.getWrapperField(this, proto.Tempo, 5));
};


/**
 * @param {?proto.Tempo|undefined} value
 * @return {!proto.Section} returns this
*/
proto.Section.prototype.setTempo = function(value) {
  return jspb.Message.setWrapperField(this, 5, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.Section} returns this
 */
proto.Section.prototype.clearTempo = function() {
  return this.setTempo(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.Section.prototype.hasTempo = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional NoteName key = 6;
 * @return {?proto.NoteName}
 */
proto.Section.prototype.getKey = function() {
  return /** @type{?proto.NoteName} */ (
    jspb.Message.getWrapperField(this, proto.NoteName, 6));
};


/**
 * @param {?proto.NoteName|undefined} value
 * @return {!proto.Section} returns this
*/
proto.Section.prototype.setKey = function(value) {
  return jspb.Message.setWrapperField(this, 6, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.Section} returns this
 */
proto.Section.prototype.clearKey = function() {
  return this.setKey(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.Section.prototype.hasKey = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * repeated MelodyReference melodies = 100;
 * @return {!Array<!proto.MelodyReference>}
 */
proto.Section.prototype.getMelodiesList = function() {
  return /** @type{!Array<!proto.MelodyReference>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.MelodyReference, 100));
};


/**
 * @param {!Array<!proto.MelodyReference>} value
 * @return {!proto.Section} returns this
*/
proto.Section.prototype.setMelodiesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 100, value);
};


/**
 * @param {!proto.MelodyReference=} opt_value
 * @param {number=} opt_index
 * @return {!proto.MelodyReference}
 */
proto.Section.prototype.addMelodies = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 100, opt_value, proto.MelodyReference, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.Section} returns this
 */
proto.Section.prototype.clearMelodiesList = function() {
  return this.setMelodiesList([]);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.Score.repeatedFields_ = [3,4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.Score.prototype.toObject = function(opt_includeInstance) {
  return proto.Score.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.Score} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Score.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: jspb.Message.getFieldWithDefault(msg, 1, ""),
    name: jspb.Message.getFieldWithDefault(msg, 2, ""),
    partsList: jspb.Message.toObjectList(msg.getPartsList(),
    proto.Part.toObject, includeInstance),
    sectionsList: jspb.Message.toObjectList(msg.getSectionsList(),
    proto.Section.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Score}
 */
proto.Score.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Score;
  return proto.Score.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Score} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Score}
 */
proto.Score.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 3:
      var value = new proto.Part;
      reader.readMessage(value,proto.Part.deserializeBinaryFromReader);
      msg.addParts(value);
      break;
    case 4:
      var value = new proto.Section;
      reader.readMessage(value,proto.Section.deserializeBinaryFromReader);
      msg.addSections(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Score.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.Score.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.Score} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Score.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getPartsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.Part.serializeBinaryToWriter
    );
  }
  f = message.getSectionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.Section.serializeBinaryToWriter
    );
  }
};


/**
 * optional string id = 1;
 * @return {string}
 */
proto.Score.prototype.getId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.Score} returns this
 */
proto.Score.prototype.setId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string name = 2;
 * @return {string}
 */
proto.Score.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.Score} returns this
 */
proto.Score.prototype.setName = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * repeated Part parts = 3;
 * @return {!Array<!proto.Part>}
 */
proto.Score.prototype.getPartsList = function() {
  return /** @type{!Array<!proto.Part>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.Part, 3));
};


/**
 * @param {!Array<!proto.Part>} value
 * @return {!proto.Score} returns this
*/
proto.Score.prototype.setPartsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.Part=} opt_value
 * @param {number=} opt_index
 * @return {!proto.Part}
 */
proto.Score.prototype.addParts = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.Part, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.Score} returns this
 */
proto.Score.prototype.clearPartsList = function() {
  return this.setPartsList([]);
};


/**
 * repeated Section sections = 4;
 * @return {!Array<!proto.Section>}
 */
proto.Score.prototype.getSectionsList = function() {
  return /** @type{!Array<!proto.Section>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.Section, 4));
};


/**
 * @param {!Array<!proto.Section>} value
 * @return {!proto.Score} returns this
*/
proto.Score.prototype.setSectionsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.Section=} opt_value
 * @param {number=} opt_index
 * @return {!proto.Section}
 */
proto.Score.prototype.addSections = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.Section, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.Score} returns this
 */
proto.Score.prototype.clearSectionsList = function() {
  return this.setSectionsList([]);
};


/**
 * @enum {number}
 */
proto.NoteLetter = {
  C: 0,
  D: 1,
  E: 2,
  F: 3,
  G: 4,
  A: 5,
  B: 6
};

/**
 * @enum {number}
 */
proto.NoteSign = {
  NATURAL: 0,
  FLAT: 1,
  DOUBLE_FLAT: 2,
  SHARP: 3,
  DOUBLE_SHARP: 4
};

/**
 * @enum {number}
 */
proto.InstrumentType = {
  HARMONIC: 0,
  DRUM: 1
};

/**
 * @enum {number}
 */
proto.MelodyType = {
  MIDI: 0,
  AUDIO: 1
};

/**
 * @enum {number}
 */
proto.MelodyInterpretationType = {
  FIXED_NONADAPTIVE: 0,
  FIXED: 1,
  RELATIVE_TO_C: 2,
  RELATIVE_TO_C_SHARP: 3,
  RELATIVE_TO_D: 4,
  RELATIVE_TO_D_SHARP: 5,
  RELATIVE_TO_E: 6,
  RELATIVE_TO_F: 7,
  RELATIVE_TO_F_SHARP: 8,
  RELATIVE_TO_G: 9,
  RELATIVE_TO_G_SHARP: 10,
  RELATIVE_TO_A: 11,
  RELATIVE_TO_A_SHARP: 12,
  RELATIVE_TO_B: 13
};

